<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth of Shadows</title>
    <style>
        html, body {
            margin: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        #startPage {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #startImage {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #startClickArea {
            position: absolute;
            cursor: pointer;
        }

        /* Game Styles */
        #game {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #mazeImg {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #mazeWrapper {
            position: relative;
            display: inline-block;
        }

        #character {
            position: absolute;
            width: 30px;
            height: auto;
            mix-blend-mode: screen;
        }

        #flashlightOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            background: #000;
            -webkit-mask-image: radial-gradient(circle at 0px 0px, transparent 0px, transparent 80px, rgba(0,0,0,0.3) 105px, rgba(0,0,0,0.7) 130px, black 160px);
            mask-image: radial-gradient(circle at 0px 0px, transparent 0px, transparent 80px, rgba(0,0,0,0.3) 105px, rgba(0,0,0,0.7) 130px, black 160px);
        }

        #flashlightOverlay.hidden {
            display: none;
        }

        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #winScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #loseScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #loseScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #restartClickArea {
            position: absolute;
            cursor: pointer;
        }

        #wrongWayScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }

        #wrongWayScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div id="startPage">
        <img id="startImage" src="finalmaze/finalmaze/start.png" alt="Start Page" />
        <div id="startClickArea"></div>
    </div>

    <script>
        const startImage = document.getElementById('startImage');
        const clickArea = document.getElementById('startClickArea');

        function positionClickArea() {
            const img = startImage;
            const rect = img.getBoundingClientRect();

            // Calculate the displayed image dimensions
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayedWidth = rect.width;
            const displayedHeight = rect.height;

            // Scale factor
            const scale = displayedWidth / naturalWidth;

            // "Start Exploration" text approximate position in original image
            // Based on the image, it's near the bottom center
            const textX = naturalWidth * 0.28;
            const textY = naturalHeight * 0.72;
            const textWidth = naturalWidth * 0.44;
            const textHeight = naturalHeight * 0.12;

            // Apply scaled position
            clickArea.style.left = (rect.left + textX * scale) + 'px';
            clickArea.style.top = (rect.top + textY * scale) + 'px';
            clickArea.style.width = (textWidth * scale) + 'px';
            clickArea.style.height = (textHeight * scale) + 'px';
        }

        startImage.onload = positionClickArea;
        window.addEventListener('resize', positionClickArea);

        clickArea.addEventListener('click', function() {
            // Remove start page and start game
            document.getElementById('startPage').remove();
            startGame();
        });

        function startGame() {
            // Create game elements
            const gameDiv = document.createElement('div');
            gameDiv.id = 'game';

            const mazeWrapper = document.createElement('div');
            mazeWrapper.id = 'mazeWrapper';

            const mazeImg = document.createElement('img');
            mazeImg.id = 'mazeImg';
            mazeImg.src = 'finalmaze/finalmaze/maze.png';
            mazeImg.alt = 'maze';

            const character = document.createElement('img');
            character.id = 'character';
            character.src = 'finalmaze/finalmaze/character.png';
            character.alt = 'Character';

            mazeWrapper.appendChild(mazeImg);
            mazeWrapper.appendChild(character);
            gameDiv.appendChild(mazeWrapper);
            document.body.appendChild(gameDiv);

            const overlay = document.createElement('div');
            overlay.id = 'flashlightOverlay';
            document.body.appendChild(overlay);

            // Wait for maze image to load, then initialize game with correct position
            mazeImg.onload = function() {
                initGame(character, overlay, mazeImg);
            };
        }

        function initGame(character, overlay, mazeImg) {
            const moveSpeed = 5;

            // Calculate character spawn position relative to displayed maze
            const mazeWidth = mazeImg.offsetWidth;
            const mazeHeight = mazeImg.offsetHeight;

            // Create off-screen canvas for collision detection
            const collisionCanvas = document.createElement('canvas');
            const collisionCtx = collisionCanvas.getContext('2d');
            collisionCanvas.width = mazeImg.naturalWidth;
            collisionCanvas.height = mazeImg.naturalHeight;
            collisionCtx.drawImage(mazeImg, 0, 0);

            // Scale factors to map displayed position to original image coordinates
            const scaleX = mazeImg.naturalWidth / mazeWidth;
            const scaleY = mazeImg.naturalHeight / mazeHeight;

            // Check if a position hits a wall (white pixel)
            function isWall(x, y) {
                // Map displayed coordinates to original image coordinates
                const imgX = Math.floor(x * scaleX);
                const imgY = Math.floor(y * scaleY);

                // Bounds check
                if (imgX < 0 || imgX >= collisionCanvas.width || imgY < 0 || imgY >= collisionCanvas.height) {
                    return true; // Out of bounds = wall
                }

                const pixel = collisionCtx.getImageData(imgX, imgY, 1, 1).data;
                // White pixels (walls) have high RGB values
                // Threshold: if average RGB > 200, it's a wall
                const brightness = (pixel[0] + pixel[1] + pixel[2]) / 3;
                return brightness > 200;
            }

            // Check collision for character at given position (using center point only)
            function canMoveTo(x, y) {
                const charWidth = character.offsetWidth;
                const charHeight = character.offsetHeight;

                // Use ONLY the character's visual center point for collision
                const centerX = x + charWidth / 2;
                const centerY = y + charHeight / 2;

                return !isWall(centerX, centerY);
            }

            // Position at top-left corridor - adjusted so CENTER is on black pixel
            const charWidth = 30; // Character width from CSS
            const charHeight = charWidth; // Approximate square
            let posX = Math.round(mazeWidth * 0.035 - charWidth / 2);
            let posY = Math.round(mazeHeight * 0.05 - charHeight / 2);

            character.style.left = posX + 'px';
            character.style.top = posY + 'px';

            // Define invisible exit zone at bottom-right (near the exit arrow)
            const exitZone = {
                x: mazeWidth * 0.96,
                y: mazeHeight * 0.88,
                width: mazeWidth * 0.04,
                height: mazeHeight * 0.10
            };

            let gameWon = false;
            let gameLost = false;
            let movementFrozen = false;

            // Wrong way detection state - detects being stuck in a small area
            let movementHistory = [];
            let wrongWayCheckInterval = null;
            let wrongWayEnabled = false;
            const OBSERVATION_WINDOW = 6000; // 6 seconds observation window
            const CHECK_INTERVAL = 200; // Check every 200ms
            const STUCK_THRESHOLD = 60; // If net displacement < 60px over 6 seconds while moving, player is stuck
            const MIN_TOTAL_MOVEMENT = 150; // Must have moved at least 150px total to be considered "trying to move"

            const keysPressed = {};

            document.addEventListener('keydown', (e) => {
                keysPressed[e.key.toLowerCase()] = true;
            });

            document.addEventListener('keyup', (e) => {
                keysPressed[e.key.toLowerCase()] = false;
            });

            // Check if character intersects exit zone
            function checkWinCondition() {
                const charWidth = character.offsetWidth;
                const charHeight = character.offsetHeight;

                // Check if character center is within exit zone
                const charCenterX = posX + charWidth / 2;
                const charCenterY = posY + charHeight / 2;

                if (charCenterX >= exitZone.x &&
                    charCenterX <= exitZone.x + exitZone.width &&
                    charCenterY >= exitZone.y &&
                    charCenterY <= exitZone.y + exitZone.height) {
                    return true;
                }
                return false;
            }

            function triggerWin() {
                gameWon = true;

                // Hide game elements
                document.getElementById('game').style.display = 'none';
                overlay.style.display = 'none';

                // Show win screen
                const winScreen = document.createElement('div');
                winScreen.id = 'winScreen';
                const winImg = document.createElement('img');
                winImg.src = 'finalmaze/finalmaze/rightway.png';
                winImg.alt = 'You Win!';
                winScreen.appendChild(winImg);
                document.body.appendChild(winScreen);
            }

            function triggerLose() {
                gameLost = true;

                // Hide game elements
                document.getElementById('game').style.display = 'none';
                overlay.style.display = 'none';

                // Show lose screen
                const loseScreen = document.createElement('div');
                loseScreen.id = 'loseScreen';

                const loseImg = document.createElement('img');
                loseImg.id = 'loseImage';
                loseImg.src = 'finalmaze/finalmaze/fail.png';
                loseImg.alt = 'You Failed';

                const restartArea = document.createElement('div');
                restartArea.id = 'restartClickArea';

                loseScreen.appendChild(loseImg);
                loseScreen.appendChild(restartArea);
                document.body.appendChild(loseScreen);

                // Position restart click area after image loads
                loseImg.onload = function() {
                    const rect = loseImg.getBoundingClientRect();
                    const naturalWidth = loseImg.naturalWidth;
                    const naturalHeight = loseImg.naturalHeight;
                    const scale = rect.width / naturalWidth;

                    // "Start Over" text position (approximately center-right, below "You failed")
                    const textX = naturalWidth * 0.45;
                    const textY = naturalHeight * 0.52;
                    const textWidth = naturalWidth * 0.35;
                    const textHeight = naturalHeight * 0.12;

                    restartArea.style.left = (rect.left + textX * scale) + 'px';
                    restartArea.style.top = (rect.top + textY * scale) + 'px';
                    restartArea.style.width = (textWidth * scale) + 'px';
                    restartArea.style.height = (textHeight * scale) + 'px';
                };

                // Restart game on click
                restartArea.addEventListener('click', function() {
                    location.reload();
                });
            }

            function gameLoop() {
                if (gameWon || gameLost) return;

                let newX = posX;
                let newY = posY;

                // Block movement while frozen (during wrong way message)
                if (!movementFrozen) {
                    // Calculate intended movement
                    if (keysPressed['w']) {
                        newY -= moveSpeed;
                    }
                    if (keysPressed['s']) {
                        newY += moveSpeed;
                    }
                    if (keysPressed['a']) {
                        newX -= moveSpeed;
                    }
                    if (keysPressed['d']) {
                        newX += moveSpeed;
                    }
                }

                // Try combined movement first
                if (canMoveTo(newX, newY)) {
                    posX = newX;
                    posY = newY;
                } else {
                    // Try horizontal only
                    if (canMoveTo(newX, posY)) {
                        posX = newX;
                    }
                    // Try vertical only
                    if (canMoveTo(posX, newY)) {
                        posY = newY;
                    }
                }

                character.style.left = posX + 'px';
                character.style.top = posY + 'px';

                // Update character glow position when flashlight is not active
                if (!flashlightActive) {
                    updateCharacterGlow();
                }

                // Check win condition
                if (checkWinCondition()) {
                    triggerWin();
                    return;
                }

                requestAnimationFrame(gameLoop);
            }

            // Flashlight system - declare BEFORE gameLoop starts
            let flashlightUses = 3;
            let flashlightActive = false;
            let flashlightTimer = null;
            let mouseX = 0;
            let mouseY = 0;

            // Get character's screen position for glow
            function getCharacterScreenPos() {
                const charRect = character.getBoundingClientRect();
                return {
                    x: charRect.left + charRect.width / 2,
                    y: charRect.top + charRect.height / 2
                };
            }

            // Update overlay with mouse-controlled flashlight
            function updateFlashlightPosition() {
                const maskValue = `radial-gradient(circle at ${mouseX}px ${mouseY}px, transparent 0px, transparent 80px, rgba(0,0,0,0.3) 105px, rgba(0,0,0,0.7) 130px, black 160px)`;
                overlay.style.webkitMaskImage = maskValue;
                overlay.style.maskImage = maskValue;
            }

            // Update overlay with small character glow only (when flashlight inactive)
            function updateCharacterGlow() {
                const charPos = getCharacterScreenPos();
                // Small glow around character - much smaller than flashlight
                const maskValue = `radial-gradient(circle at ${charPos.x}px ${charPos.y}px, transparent 0px, transparent 20px, rgba(0,0,0,0.5) 30px, black 40px)`;
                overlay.style.webkitMaskImage = maskValue;
                overlay.style.maskImage = maskValue;
            }

            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                if (flashlightActive) {
                    updateFlashlightPosition();
                }
            });

            function startFlashlight() {
                if (flashlightUses <= 0 || flashlightActive) return;

                // Stop wrong way detection when flashlight is active
                stopWrongWayDetection();
                wrongWayEnabled = false;

                flashlightActive = true;
                updateFlashlightPosition();

                flashlightTimer = setTimeout(() => {
                    endFlashlight();
                }, 15000);
            }

            // Wrong way detection system - detects being stuck in a small area
            // Only active AFTER flashlight ends (with 2 second delay)
            function startWrongWayDetection() {
                movementHistory = [];
                wrongWayEnabled = false;

                // Wait 2 seconds after flashlight ends before enabling detection
                setTimeout(() => {
                    if (gameWon || gameLost || flashlightActive) return;
                    wrongWayEnabled = true;
                }, 2000);

                wrongWayCheckInterval = setInterval(() => {
                    if (gameWon || gameLost || movementFrozen || flashlightActive || !wrongWayEnabled) return;

                    const now = Date.now();

                    // Record current position
                    movementHistory.push({ x: posX, y: posY, time: now });

                    // Keep only last 6 seconds of history
                    movementHistory = movementHistory.filter(p => now - p.time < OBSERVATION_WINDOW);

                    // Check if stuck (need at least 6 seconds of data)
                    if (checkIfStuck()) {
                        triggerWrongWay();
                    }
                }, CHECK_INTERVAL);
            }

            function stopWrongWayDetection() {
                if (wrongWayCheckInterval) {
                    clearInterval(wrongWayCheckInterval);
                    wrongWayCheckInterval = null;
                }
                movementHistory = [];
                wrongWayEnabled = false;
            }

            function checkIfStuck() {
                // Need at least 6 seconds of movement history
                if (movementHistory.length < 25) return false; // ~5 seconds at 200ms intervals

                const oldest = movementHistory[0];
                const newest = movementHistory[movementHistory.length - 1];
                const timeDiff = newest.time - oldest.time;

                // Must have at least 5 seconds of data
                if (timeDiff < 5000) return false;

                // Calculate NET displacement (straight line from start to end)
                const netDx = newest.x - oldest.x;
                const netDy = newest.y - oldest.y;
                const netDisplacement = Math.sqrt(netDx * netDx + netDy * netDy);

                // Calculate TOTAL movement (sum of all individual movements)
                let totalMovement = 0;
                for (let i = 1; i < movementHistory.length; i++) {
                    const dx = movementHistory[i].x - movementHistory[i-1].x;
                    const dy = movementHistory[i].y - movementHistory[i-1].y;
                    totalMovement += Math.sqrt(dx * dx + dy * dy);
                }

                // Player is STUCK if:
                // 1. They've been moving a lot (total movement > threshold)
                // 2. But haven't made progress (net displacement is small)
                // This means they're moving back and forth in the same area
                if (totalMovement >= MIN_TOTAL_MOVEMENT && netDisplacement < STUCK_THRESHOLD) {
                    return true;
                }

                return false;
            }

            function triggerWrongWay() {
                stopWrongWayDetection();

                // Consume a flashlight use
                flashlightUses--;

                // Freeze movement
                movementFrozen = true;

                // Show wrong way screen
                const wrongWayScreen = document.createElement('div');
                wrongWayScreen.id = 'wrongWayScreen';
                const wrongWayImg = document.createElement('img');
                wrongWayImg.src = 'finalmaze/finalmaze/wrongway.png';
                wrongWayImg.alt = 'You take the wrong way';
                wrongWayScreen.appendChild(wrongWayImg);
                document.body.appendChild(wrongWayScreen);

                // After 2 seconds, check if FAILED or continue
                setTimeout(() => {
                    wrongWayScreen.remove();
                    movementFrozen = false;

                    if (flashlightUses <= 0) {
                        // No flashlights left after wrong way = FAILED
                        triggerLose();
                    } else {
                        // Have flashlights remaining - start next one
                        startFlashlight();
                    }
                }, 2000);
            }

            function endFlashlight() {
                flashlightActive = false;
                flashlightUses--;

                // Switch to character glow only - darkness overlay stays active
                updateCharacterGlow();

                if (flashlightTimer) {
                    clearTimeout(flashlightTimer);
                    flashlightTimer = null;
                }

                // Start wrong way detection (with 2 second delay before enabling)
                // Detects if player gets stuck moving in a small area
                startWrongWayDetection();
            }

            // Press C to activate next flashlight (disabled during frozen state)
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'c' && !flashlightActive && flashlightUses > 0 && !movementFrozen) {
                    startFlashlight();
                }
            });

            // Initialize character glow first, then start flashlight
            updateCharacterGlow();

            // Start game loop
            gameLoop();

            // Start flashlight immediately
            startFlashlight();
        }
    </script>
</body>
</html>
