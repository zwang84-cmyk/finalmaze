<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth of Shadows</title>
    <style>
        html, body {
            margin: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        #startPage {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #startImage {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #startClickArea {
            position: absolute;
            cursor: pointer;
        }

        /* Game Styles */
        #game {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #mazeImg {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #mazeWrapper {
            position: relative;
            display: inline-block;
        }

        #character {
            position: absolute;
            width: 30px;
            height: auto;
            mix-blend-mode: screen;
        }

        #flashlightOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            background: #000;
            -webkit-mask-image: radial-gradient(circle at 0px 0px, transparent 0px, transparent 60px, rgba(0,0,0,0.3) 80px, rgba(0,0,0,0.7) 100px, black 120px);
            mask-image: radial-gradient(circle at 0px 0px, transparent 0px, transparent 60px, rgba(0,0,0,0.3) 80px, rgba(0,0,0,0.7) 100px, black 120px);
        }

        #flashlightOverlay.hidden {
            display: none;
        }

        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #winScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #loseScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #loseScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #restartClickArea {
            position: absolute;
            cursor: pointer;
        }

        #wrongWayScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }

        #wrongWayScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div id="startPage">
        <img id="startImage" src="finalmaze/finalmaze/start.png" alt="Start Page" />
        <div id="startClickArea"></div>
    </div>

    <script>
        const startImage = document.getElementById('startImage');
        const clickArea = document.getElementById('startClickArea');

        function positionClickArea() {
            const img = startImage;
            const rect = img.getBoundingClientRect();

            // Calculate the displayed image dimensions
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayedWidth = rect.width;
            const displayedHeight = rect.height;

            // Scale factor
            const scale = displayedWidth / naturalWidth;

            // "Start Exploration" text approximate position in original image
            // Based on the image, it's near the bottom center
            const textX = naturalWidth * 0.28;
            const textY = naturalHeight * 0.72;
            const textWidth = naturalWidth * 0.44;
            const textHeight = naturalHeight * 0.12;

            // Apply scaled position
            clickArea.style.left = (rect.left + textX * scale) + 'px';
            clickArea.style.top = (rect.top + textY * scale) + 'px';
            clickArea.style.width = (textWidth * scale) + 'px';
            clickArea.style.height = (textHeight * scale) + 'px';
        }

        startImage.onload = positionClickArea;
        window.addEventListener('resize', positionClickArea);

        clickArea.addEventListener('click', function() {
            // Remove start page and start game
            document.getElementById('startPage').remove();
            startGame();
        });

        function startGame() {
            // Create game elements
            const gameDiv = document.createElement('div');
            gameDiv.id = 'game';

            const mazeWrapper = document.createElement('div');
            mazeWrapper.id = 'mazeWrapper';

            const mazeImg = document.createElement('img');
            mazeImg.id = 'mazeImg';
            mazeImg.src = 'finalmaze/finalmaze/maze.png';
            mazeImg.alt = 'maze';

            const character = document.createElement('img');
            character.id = 'character';
            character.src = 'finalmaze/finalmaze/character.png';
            character.alt = 'Character';

            mazeWrapper.appendChild(mazeImg);
            mazeWrapper.appendChild(character);
            gameDiv.appendChild(mazeWrapper);
            document.body.appendChild(gameDiv);

            const overlay = document.createElement('div');
            overlay.id = 'flashlightOverlay';
            document.body.appendChild(overlay);

            // Wait for maze image to load, then initialize game with correct position
            mazeImg.onload = function() {
                initGame(character, overlay, mazeImg);
            };
        }

        function initGame(character, overlay, mazeImg) {
            const moveSpeed = 5;

            // Calculate character spawn position relative to displayed maze
            const mazeWidth = mazeImg.offsetWidth;
            const mazeHeight = mazeImg.offsetHeight;

            // Create off-screen canvas for collision detection
            const collisionCanvas = document.createElement('canvas');
            const collisionCtx = collisionCanvas.getContext('2d');
            collisionCanvas.width = mazeImg.naturalWidth;
            collisionCanvas.height = mazeImg.naturalHeight;
            collisionCtx.drawImage(mazeImg, 0, 0);

            // Scale factors to map displayed position to original image coordinates
            const scaleX = mazeImg.naturalWidth / mazeWidth;
            const scaleY = mazeImg.naturalHeight / mazeHeight;

            // Check if a position hits a wall (white pixel)
            function isWall(x, y) {
                // Map displayed coordinates to original image coordinates
                const imgX = Math.floor(x * scaleX);
                const imgY = Math.floor(y * scaleY);

                // Bounds check
                if (imgX < 0 || imgX >= collisionCanvas.width || imgY < 0 || imgY >= collisionCanvas.height) {
                    return true; // Out of bounds = wall
                }

                const pixel = collisionCtx.getImageData(imgX, imgY, 1, 1).data;
                // White pixels (walls) have high RGB values
                // Threshold: if average RGB > 200, it's a wall
                const brightness = (pixel[0] + pixel[1] + pixel[2]) / 3;
                return brightness > 200;
            }

            // Check collision for character at given position (using center point only)
            function canMoveTo(x, y) {
                const charWidth = character.offsetWidth;
                const charHeight = character.offsetHeight;

                // Use ONLY the character's visual center point for collision
                const centerX = x + charWidth / 2;
                const centerY = y + charHeight / 2;

                return !isWall(centerX, centerY);
            }

            // Position at top-left corridor - adjusted so CENTER is on black pixel
            const charWidth = 30; // Character width from CSS
            const charHeight = charWidth; // Approximate square
            let posX = Math.round(mazeWidth * 0.035 - charWidth / 2);
            let posY = Math.round(mazeHeight * 0.05 - charHeight / 2);

            character.style.left = posX + 'px';
            character.style.top = posY + 'px';

            // Define invisible exit zone at bottom-right (near the exit arrow)
            const exitZone = {
                x: mazeWidth * 0.96,
                y: mazeHeight * 0.88,
                width: mazeWidth * 0.04,
                height: mazeHeight * 0.10
            };

            let gameWon = false;
            let gameLost = false;
            let movementFrozen = false;

            // Wrong way detection state
            let movementHistory = [];
            let distanceHistory = [];
            let wrongWayCheckInterval = null;
            const SUSTAINED_TIME = 1500; // 1.5 seconds of sustained wrong movement
            const CHECK_INTERVAL = 200; // Check every 200ms

            // Calculate distance to exit
            function getDistanceToExit() {
                const charCenterX = posX + character.offsetWidth / 2;
                const charCenterY = posY + character.offsetHeight / 2;
                const exitCenterX = exitZone.x + exitZone.width / 2;
                const exitCenterY = exitZone.y + exitZone.height / 2;
                return Math.sqrt(Math.pow(charCenterX - exitCenterX, 2) + Math.pow(charCenterY - exitCenterY, 2));
            }

            const keysPressed = {};

            document.addEventListener('keydown', (e) => {
                keysPressed[e.key.toLowerCase()] = true;
            });

            document.addEventListener('keyup', (e) => {
                keysPressed[e.key.toLowerCase()] = false;
            });

            // Check if character intersects exit zone
            function checkWinCondition() {
                const charWidth = character.offsetWidth;
                const charHeight = character.offsetHeight;

                // Check if character center is within exit zone
                const charCenterX = posX + charWidth / 2;
                const charCenterY = posY + charHeight / 2;

                if (charCenterX >= exitZone.x &&
                    charCenterX <= exitZone.x + exitZone.width &&
                    charCenterY >= exitZone.y &&
                    charCenterY <= exitZone.y + exitZone.height) {
                    return true;
                }
                return false;
            }

            function triggerWin() {
                gameWon = true;

                // Hide game elements
                document.getElementById('game').style.display = 'none';
                overlay.style.display = 'none';

                // Show win screen
                const winScreen = document.createElement('div');
                winScreen.id = 'winScreen';
                const winImg = document.createElement('img');
                winImg.src = 'finalmaze/finalmaze/rightway.png';
                winImg.alt = 'You Win!';
                winScreen.appendChild(winImg);
                document.body.appendChild(winScreen);
            }

            function triggerLose() {
                gameLost = true;

                // Hide game elements
                document.getElementById('game').style.display = 'none';
                overlay.style.display = 'none';

                // Show lose screen
                const loseScreen = document.createElement('div');
                loseScreen.id = 'loseScreen';

                const loseImg = document.createElement('img');
                loseImg.id = 'loseImage';
                loseImg.src = 'finalmaze/finalmaze/fail.png';
                loseImg.alt = 'You Failed';

                const restartArea = document.createElement('div');
                restartArea.id = 'restartClickArea';

                loseScreen.appendChild(loseImg);
                loseScreen.appendChild(restartArea);
                document.body.appendChild(loseScreen);

                // Position restart click area after image loads
                loseImg.onload = function() {
                    const rect = loseImg.getBoundingClientRect();
                    const naturalWidth = loseImg.naturalWidth;
                    const naturalHeight = loseImg.naturalHeight;
                    const scale = rect.width / naturalWidth;

                    // "Start Over" text position (approximately center-right, below "You failed")
                    const textX = naturalWidth * 0.45;
                    const textY = naturalHeight * 0.52;
                    const textWidth = naturalWidth * 0.35;
                    const textHeight = naturalHeight * 0.12;

                    restartArea.style.left = (rect.left + textX * scale) + 'px';
                    restartArea.style.top = (rect.top + textY * scale) + 'px';
                    restartArea.style.width = (textWidth * scale) + 'px';
                    restartArea.style.height = (textHeight * scale) + 'px';
                };

                // Restart game on click
                restartArea.addEventListener('click', function() {
                    location.reload();
                });
            }

            function gameLoop() {
                if (gameWon || gameLost) return;

                let newX = posX;
                let newY = posY;

                // Block movement while frozen (during wrong way message)
                if (!movementFrozen) {
                    // Calculate intended movement
                    if (keysPressed['w']) {
                        newY -= moveSpeed;
                    }
                    if (keysPressed['s']) {
                        newY += moveSpeed;
                    }
                    if (keysPressed['a']) {
                        newX -= moveSpeed;
                    }
                    if (keysPressed['d']) {
                        newX += moveSpeed;
                    }
                }

                // Try combined movement first
                if (canMoveTo(newX, newY)) {
                    posX = newX;
                    posY = newY;
                } else {
                    // Try horizontal only
                    if (canMoveTo(newX, posY)) {
                        posX = newX;
                    }
                    // Try vertical only
                    if (canMoveTo(posX, newY)) {
                        posY = newY;
                    }
                }

                character.style.left = posX + 'px';
                character.style.top = posY + 'px';

                // Update character glow position when flashlight is not active
                if (!flashlightActive) {
                    updateCharacterGlow();
                }

                // Check win condition
                if (checkWinCondition()) {
                    triggerWin();
                    return;
                }

                requestAnimationFrame(gameLoop);
            }

            // Flashlight system - declare BEFORE gameLoop starts
            let flashlightUses = 3;
            let flashlightActive = false;
            let flashlightTimer = null;
            let mouseX = 0;
            let mouseY = 0;

            // Get character's screen position for glow
            function getCharacterScreenPos() {
                const charRect = character.getBoundingClientRect();
                return {
                    x: charRect.left + charRect.width / 2,
                    y: charRect.top + charRect.height / 2
                };
            }

            // Update overlay with mouse-controlled flashlight
            function updateFlashlightPosition() {
                const maskValue = `radial-gradient(circle at ${mouseX}px ${mouseY}px, transparent 0px, transparent 60px, rgba(0,0,0,0.3) 80px, rgba(0,0,0,0.7) 100px, black 120px)`;
                overlay.style.webkitMaskImage = maskValue;
                overlay.style.maskImage = maskValue;
            }

            // Update overlay with small character glow only (when flashlight inactive)
            function updateCharacterGlow() {
                const charPos = getCharacterScreenPos();
                // Small glow around character - much smaller than flashlight
                const maskValue = `radial-gradient(circle at ${charPos.x}px ${charPos.y}px, transparent 0px, transparent 20px, rgba(0,0,0,0.5) 30px, black 40px)`;
                overlay.style.webkitMaskImage = maskValue;
                overlay.style.maskImage = maskValue;
            }

            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                if (flashlightActive) {
                    updateFlashlightPosition();
                }
            });

            function startFlashlight() {
                if (flashlightUses <= 0 || flashlightActive) return;

                flashlightActive = true;
                updateFlashlightPosition();

                // Start wrong way detection
                startWrongWayDetection();

                flashlightTimer = setTimeout(() => {
                    endFlashlight();
                }, 12000);
            }

            // Wrong way detection system - tracks sustained movement into dead ends
            function startWrongWayDetection() {
                movementHistory = [];
                distanceHistory = [];

                wrongWayCheckInterval = setInterval(() => {
                    if (gameWon || gameLost || movementFrozen || !flashlightActive) return;

                    const now = Date.now();

                    // Record current position and distance
                    movementHistory.push({ x: posX, y: posY, time: now });
                    distanceHistory.push({ distance: getDistanceToExit(), time: now });

                    // Keep only last 2 seconds of history
                    movementHistory = movementHistory.filter(p => now - p.time < 2000);
                    distanceHistory = distanceHistory.filter(d => now - d.time < 2000);

                    // Check wrong way conditions
                    if (checkWrongWayConditions()) {
                        triggerWrongWay();
                    }
                }, CHECK_INTERVAL);
            }

            function stopWrongWayDetection() {
                if (wrongWayCheckInterval) {
                    clearInterval(wrongWayCheckInterval);
                    wrongWayCheckInterval = null;
                }
                movementHistory = [];
                distanceHistory = [];
            }

            function checkWrongWayConditions() {
                // Need enough history (at least 1.5 seconds worth)
                if (movementHistory.length < 7 || distanceHistory.length < 7) return false;

                const oldest = movementHistory[0];
                const newest = movementHistory[movementHistory.length - 1];
                const timeDiff = newest.time - oldest.time;

                // Condition 1: Sustained movement for at least 1.5 seconds
                if (timeDiff < SUSTAINED_TIME) return false;

                // Check if there's been actual movement (not standing still)
                const totalDx = newest.x - oldest.x;
                const totalDy = newest.y - oldest.y;
                const totalDistance = Math.sqrt(totalDx * totalDx + totalDy * totalDy);
                if (totalDistance < 50) return false; // Must have moved at least 50px

                // Condition 2: Determine movement direction and check if heading into dead end
                let dirX = 0, dirY = 0;
                if (Math.abs(totalDx) > Math.abs(totalDy)) {
                    dirX = totalDx > 0 ? 1 : -1;
                } else {
                    dirY = totalDy > 0 ? 1 : -1;
                }

                // Check if path ahead is blocked (dead end corridor)
                const checkDistances = [40, 60, 80, 100];
                let blockedAhead = 0;
                for (const d of checkDistances) {
                    if (!canMoveTo(posX + dirX * d, posY + dirY * d)) {
                        blockedAhead++;
                    }
                }
                // Not heading into a dead end if most of the path is open
                if (blockedAhead < 3) return false;

                // Condition 3: Not getting closer to exit during this movement
                const oldestDist = distanceHistory[0].distance;
                const newestDist = distanceHistory[distanceHistory.length - 1].distance;
                // If getting significantly closer to exit, not wrong way
                if (newestDist < oldestDist - 20) return false;

                // All conditions met: sustained movement into dead end while not approaching exit
                return true;
            }

            function triggerWrongWay() {
                stopWrongWayDetection();

                // Stop current flashlight timer
                if (flashlightTimer) {
                    clearTimeout(flashlightTimer);
                    flashlightTimer = null;
                }
                flashlightActive = false;

                // Consume a flashlight use
                flashlightUses--;

                // Switch to darkness with character glow
                updateCharacterGlow();

                // Freeze movement
                movementFrozen = true;

                // Show wrong way screen
                const wrongWayScreen = document.createElement('div');
                wrongWayScreen.id = 'wrongWayScreen';
                const wrongWayImg = document.createElement('img');
                wrongWayImg.src = 'finalmaze/finalmaze/wrongway.png';
                wrongWayImg.alt = 'You take the wrong way';
                wrongWayScreen.appendChild(wrongWayImg);
                document.body.appendChild(wrongWayScreen);

                // After 2 seconds, check if FAILED or continue
                setTimeout(() => {
                    wrongWayScreen.remove();
                    movementFrozen = false;

                    if (flashlightUses <= 0) {
                        // No flashlights left after wrong way = FAILED
                        triggerLose();
                    } else {
                        // Have flashlights remaining - start next one
                        startFlashlight();
                    }
                }, 2000);
            }

            function endFlashlight() {
                // Stop wrong way detection
                stopWrongWayDetection();

                flashlightActive = false;
                flashlightUses--;

                // Switch to character glow only - darkness overlay stays active
                updateCharacterGlow();

                if (flashlightTimer) {
                    clearTimeout(flashlightTimer);
                    flashlightTimer = null;
                }

                // Flashlight ending just switches to darkness
                // Player continues freely with character glow
                // Press C to use next flashlight when ready
                // Wrong way is detected DURING gameplay, not when flashlight ends
            }

            // Press C to activate next flashlight (disabled during frozen state)
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'c' && !flashlightActive && flashlightUses > 0 && !movementFrozen) {
                    startFlashlight();
                }
            });

            // Initialize character glow first, then start flashlight
            updateCharacterGlow();

            // Start game loop
            gameLoop();

            // Start flashlight immediately
            startFlashlight();
        }
    </script>
</body>
</html>
