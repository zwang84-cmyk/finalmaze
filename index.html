<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth of Shadows</title>
    <style>
        html, body {
            margin: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        #startPage {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #startImage {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #startClickArea {
            position: absolute;
            cursor: pointer;
        }

        /* Game Styles */
        #game {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #mazeImg {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #mazeWrapper {
            position: relative;
            display: inline-block;
        }

        #character {
            position: absolute;
            width: 30px;
            height: auto;
            mix-blend-mode: screen;
        }

        #flashlightOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            background: #000;
            -webkit-mask-image: radial-gradient(circle at 0px 0px, transparent 0px, transparent 60px, rgba(0,0,0,0.3) 80px, rgba(0,0,0,0.7) 100px, black 120px);
            mask-image: radial-gradient(circle at 0px 0px, transparent 0px, transparent 60px, rgba(0,0,0,0.3) 80px, rgba(0,0,0,0.7) 100px, black 120px);
        }

        #flashlightOverlay.hidden {
            display: none;
        }

        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #winScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #loseScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #loseScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        #restartClickArea {
            position: absolute;
            cursor: pointer;
        }

        #wrongWayScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }

        #wrongWayScreen img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div id="startPage">
        <img id="startImage" src="finalmaze/finalmaze/start.png" alt="Start Page" />
        <div id="startClickArea"></div>
    </div>

    <script>
        const startImage = document.getElementById('startImage');
        const clickArea = document.getElementById('startClickArea');

        function positionClickArea() {
            const img = startImage;
            const rect = img.getBoundingClientRect();

            // Calculate the displayed image dimensions
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayedWidth = rect.width;
            const displayedHeight = rect.height;

            // Scale factor
            const scale = displayedWidth / naturalWidth;

            // "Start Exploration" text approximate position in original image
            // Based on the image, it's near the bottom center
            const textX = naturalWidth * 0.28;
            const textY = naturalHeight * 0.72;
            const textWidth = naturalWidth * 0.44;
            const textHeight = naturalHeight * 0.12;

            // Apply scaled position
            clickArea.style.left = (rect.left + textX * scale) + 'px';
            clickArea.style.top = (rect.top + textY * scale) + 'px';
            clickArea.style.width = (textWidth * scale) + 'px';
            clickArea.style.height = (textHeight * scale) + 'px';
        }

        startImage.onload = positionClickArea;
        window.addEventListener('resize', positionClickArea);

        clickArea.addEventListener('click', function() {
            // Remove start page and start game
            document.getElementById('startPage').remove();
            startGame();
        });

        function startGame() {
            // Create game elements
            const gameDiv = document.createElement('div');
            gameDiv.id = 'game';

            const mazeWrapper = document.createElement('div');
            mazeWrapper.id = 'mazeWrapper';

            const mazeImg = document.createElement('img');
            mazeImg.id = 'mazeImg';
            mazeImg.src = 'finalmaze/finalmaze/maze.png';
            mazeImg.alt = 'maze';

            const character = document.createElement('img');
            character.id = 'character';
            character.src = 'finalmaze/finalmaze/character.png';
            character.alt = 'Character';

            mazeWrapper.appendChild(mazeImg);
            mazeWrapper.appendChild(character);
            gameDiv.appendChild(mazeWrapper);
            document.body.appendChild(gameDiv);

            const overlay = document.createElement('div');
            overlay.id = 'flashlightOverlay';
            document.body.appendChild(overlay);

            // Wait for maze image to load, then initialize game with correct position
            mazeImg.onload = function() {
                initGame(character, overlay, mazeImg);
            };
        }

        function initGame(character, overlay, mazeImg) {
            const moveSpeed = 5;

            // Calculate character spawn position relative to displayed maze
            const mazeWidth = mazeImg.offsetWidth;
            const mazeHeight = mazeImg.offsetHeight;

            // Create off-screen canvas for collision detection
            const collisionCanvas = document.createElement('canvas');
            const collisionCtx = collisionCanvas.getContext('2d');
            collisionCanvas.width = mazeImg.naturalWidth;
            collisionCanvas.height = mazeImg.naturalHeight;
            collisionCtx.drawImage(mazeImg, 0, 0);

            // Scale factors to map displayed position to original image coordinates
            const scaleX = mazeImg.naturalWidth / mazeWidth;
            const scaleY = mazeImg.naturalHeight / mazeHeight;

            // Check if a position hits a wall (white pixel)
            function isWall(x, y) {
                // Map displayed coordinates to original image coordinates
                const imgX = Math.floor(x * scaleX);
                const imgY = Math.floor(y * scaleY);

                // Bounds check
                if (imgX < 0 || imgX >= collisionCanvas.width || imgY < 0 || imgY >= collisionCanvas.height) {
                    return true; // Out of bounds = wall
                }

                const pixel = collisionCtx.getImageData(imgX, imgY, 1, 1).data;
                // White pixels (walls) have high RGB values
                // Threshold: if average RGB > 200, it's a wall
                const brightness = (pixel[0] + pixel[1] + pixel[2]) / 3;
                return brightness > 200;
            }

            // Check collision for character at given position (using center point only)
            function canMoveTo(x, y) {
                const charWidth = character.offsetWidth;
                const charHeight = character.offsetHeight;

                // Use ONLY the character's visual center point for collision
                const centerX = x + charWidth / 2;
                const centerY = y + charHeight / 2;

                return !isWall(centerX, centerY);
            }

            // Position at top-left corridor - adjusted so CENTER is on black pixel
            const charWidth = 30; // Character width from CSS
            const charHeight = charWidth; // Approximate square
            let posX = Math.round(mazeWidth * 0.035 - charWidth / 2);
            let posY = Math.round(mazeHeight * 0.05 - charHeight / 2);

            character.style.left = posX + 'px';
            character.style.top = posY + 'px';

            // Define invisible exit zone at bottom-right (near the exit arrow)
            const exitZone = {
                x: mazeWidth * 0.96,
                y: mazeHeight * 0.88,
                width: mazeWidth * 0.04,
                height: mazeHeight * 0.10
            };

            let gameWon = false;
            let gameLost = false;
            let movementFrozen = false;

            const keysPressed = {};

            document.addEventListener('keydown', (e) => {
                keysPressed[e.key.toLowerCase()] = true;
            });

            document.addEventListener('keyup', (e) => {
                keysPressed[e.key.toLowerCase()] = false;
            });

            // Check if character intersects exit zone
            function checkWinCondition() {
                const charWidth = character.offsetWidth;
                const charHeight = character.offsetHeight;

                // Check if character center is within exit zone
                const charCenterX = posX + charWidth / 2;
                const charCenterY = posY + charHeight / 2;

                if (charCenterX >= exitZone.x &&
                    charCenterX <= exitZone.x + exitZone.width &&
                    charCenterY >= exitZone.y &&
                    charCenterY <= exitZone.y + exitZone.height) {
                    return true;
                }
                return false;
            }

            function triggerWin() {
                gameWon = true;

                // Hide game elements
                document.getElementById('game').style.display = 'none';
                overlay.style.display = 'none';

                // Show win screen
                const winScreen = document.createElement('div');
                winScreen.id = 'winScreen';
                const winImg = document.createElement('img');
                winImg.src = 'finalmaze/finalmaze/rightway.png';
                winImg.alt = 'You Win!';
                winScreen.appendChild(winImg);
                document.body.appendChild(winScreen);
            }

            function triggerLose() {
                gameLost = true;

                // Hide game elements
                document.getElementById('game').style.display = 'none';
                overlay.style.display = 'none';

                // Show lose screen
                const loseScreen = document.createElement('div');
                loseScreen.id = 'loseScreen';

                const loseImg = document.createElement('img');
                loseImg.id = 'loseImage';
                loseImg.src = 'finalmaze/finalmaze/fail.png';
                loseImg.alt = 'You Failed';

                const restartArea = document.createElement('div');
                restartArea.id = 'restartClickArea';

                loseScreen.appendChild(loseImg);
                loseScreen.appendChild(restartArea);
                document.body.appendChild(loseScreen);

                // Position restart click area after image loads
                loseImg.onload = function() {
                    const rect = loseImg.getBoundingClientRect();
                    const naturalWidth = loseImg.naturalWidth;
                    const naturalHeight = loseImg.naturalHeight;
                    const scale = rect.width / naturalWidth;

                    // "Start Over" text position (approximately center-right, below "You failed")
                    const textX = naturalWidth * 0.45;
                    const textY = naturalHeight * 0.52;
                    const textWidth = naturalWidth * 0.35;
                    const textHeight = naturalHeight * 0.12;

                    restartArea.style.left = (rect.left + textX * scale) + 'px';
                    restartArea.style.top = (rect.top + textY * scale) + 'px';
                    restartArea.style.width = (textWidth * scale) + 'px';
                    restartArea.style.height = (textHeight * scale) + 'px';
                };

                // Restart game on click
                restartArea.addEventListener('click', function() {
                    location.reload();
                });
            }

            function gameLoop() {
                if (gameWon || gameLost) return;

                let newX = posX;
                let newY = posY;

                // Block movement while frozen (during wrong way message)
                if (!movementFrozen) {
                    // Calculate intended movement
                    if (keysPressed['w']) {
                        newY -= moveSpeed;
                    }
                    if (keysPressed['s']) {
                        newY += moveSpeed;
                    }
                    if (keysPressed['a']) {
                        newX -= moveSpeed;
                    }
                    if (keysPressed['d']) {
                        newX += moveSpeed;
                    }
                }

                // Try combined movement first
                if (canMoveTo(newX, newY)) {
                    posX = newX;
                    posY = newY;
                } else {
                    // Try horizontal only
                    if (canMoveTo(newX, posY)) {
                        posX = newX;
                    }
                    // Try vertical only
                    if (canMoveTo(posX, newY)) {
                        posY = newY;
                    }
                }

                character.style.left = posX + 'px';
                character.style.top = posY + 'px';

                // Update character glow position when flashlight is not active
                if (!flashlightActive) {
                    updateCharacterGlow();
                }

                // Check win condition
                if (checkWinCondition()) {
                    triggerWin();
                    return;
                }

                requestAnimationFrame(gameLoop);
            }

            // Flashlight system - declare BEFORE gameLoop starts
            let flashlightUses = 3;
            let flashlightActive = false;
            let flashlightTimer = null;
            let mouseX = 0;
            let mouseY = 0;

            // Get character's screen position for glow
            function getCharacterScreenPos() {
                const charRect = character.getBoundingClientRect();
                return {
                    x: charRect.left + charRect.width / 2,
                    y: charRect.top + charRect.height / 2
                };
            }

            // Update overlay with mouse-controlled flashlight
            function updateFlashlightPosition() {
                const maskValue = `radial-gradient(circle at ${mouseX}px ${mouseY}px, transparent 0px, transparent 60px, rgba(0,0,0,0.3) 80px, rgba(0,0,0,0.7) 100px, black 120px)`;
                overlay.style.webkitMaskImage = maskValue;
                overlay.style.maskImage = maskValue;
            }

            // Update overlay with small character glow only (when flashlight inactive)
            function updateCharacterGlow() {
                const charPos = getCharacterScreenPos();
                // Small glow around character - much smaller than flashlight
                const maskValue = `radial-gradient(circle at ${charPos.x}px ${charPos.y}px, transparent 0px, transparent 20px, rgba(0,0,0,0.5) 30px, black 40px)`;
                overlay.style.webkitMaskImage = maskValue;
                overlay.style.maskImage = maskValue;
            }

            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                if (flashlightActive) {
                    updateFlashlightPosition();
                }
            });

            function startFlashlight() {
                if (flashlightUses <= 0 || flashlightActive) return;

                flashlightActive = true;
                updateFlashlightPosition();

                flashlightTimer = setTimeout(() => {
                    endFlashlight();
                }, 12000);
            }

            function endFlashlight() {
                flashlightActive = false;
                flashlightUses--;
                // Switch to character glow only - darkness overlay stays active
                updateCharacterGlow();
                if (flashlightTimer) {
                    clearTimeout(flashlightTimer);
                    flashlightTimer = null;
                }

                // If player hasn't won yet, trigger dead-end penalty
                if (!gameWon) {
                    // Check for lose condition: all flashlights used
                    if (flashlightUses <= 0) {
                        triggerLose();
                        return;
                    }

                    // Freeze movement and show wrong way message
                    movementFrozen = true;

                    const wrongWayScreen = document.createElement('div');
                    wrongWayScreen.id = 'wrongWayScreen';
                    const wrongWayImg = document.createElement('img');
                    wrongWayImg.src = 'finalmaze/finalmaze/wrongway.png';
                    wrongWayImg.alt = 'You take the wrong way';
                    wrongWayScreen.appendChild(wrongWayImg);
                    document.body.appendChild(wrongWayScreen);

                    // After 2 seconds, hide message and start next flashlight
                    setTimeout(() => {
                        wrongWayScreen.remove();
                        movementFrozen = false;
                        startFlashlight();
                    }, 2000);
                }
            }

            // Press C to activate next flashlight (disabled during frozen state)
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'c' && !flashlightActive && flashlightUses > 0 && !movementFrozen) {
                    startFlashlight();
                }
            });

            // Initialize character glow first, then start flashlight
            updateCharacterGlow();

            // Start game loop
            gameLoop();

            // Start flashlight immediately
            startFlashlight();
        }
    </script>
</body>
</html>
