<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth of Shadows</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: 'Creepster', cursive, Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 1200px;
            height: 800px;
            border: 3px solid #333;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }

        /* Fixed maze background - NEVER changes */
        #mazeBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('finalmaze/maze.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 1;
        }

        /* Game canvas layer on top of fixed maze */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* Overlay screens */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 10;
            display: none;
        }

        .overlay.active {
            display: block;
        }

        #startOverlay {
            background-image: url('finalmaze/start.png');
        }

        #rightwayOverlay {
            background-image: url('finalmaze/rightway.png');
        }

        #wrongwayOverlay {
            background-image: url('finalmaze/wrongway.png');
        }

        #failOverlay {
            background-image: url('finalmaze/fail.png');
            cursor: pointer;
        }

        #startButton {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid white;
            cursor: pointer;
            font-family: inherit;
            z-index: 11;
            transition: all 0.3s;
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-50%) scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Fixed maze background - this NEVER changes -->
        <div id="mazeBackground"></div>

        <!-- Game canvas for player and effects -->
        <canvas id="gameCanvas"></canvas>

        <!-- Overlays for different game states -->
        <div id="startOverlay" class="overlay active"></div>
        <button id="startButton">Start Exploration</button>
        <div id="rightwayOverlay" class="overlay"></div>
        <div id="wrongwayOverlay" class="overlay"></div>
        <div id="failOverlay" class="overlay"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size to match container
        canvas.width = 1200;
        canvas.height = 800;

        // Game state
        let gameState = 'start'; // start, playing, won, failed
        let player = {
            x: 50,
            y: 50,
            size: 15,
            speed: 3
        };

        let flashlights = 3;
        let flashlightActive = false;
        let flashlightTimer = 0;
        const FLASHLIGHT_DURATION = 12000; // 12 seconds in milliseconds
        let lastTime = Date.now();

        // Darkness overlay
        let darknessAlpha = 0.95; // Very dark when flashlight is off

        // Keys pressed
        const keys = {};

        // Load maze image for collision detection
        const mazeImg = new Image();
        mazeImg.src = 'finalmaze/maze.png';
        let mazeLoaded = false;

        mazeImg.onload = () => {
            mazeLoaded = true;
            console.log('Maze loaded for collision detection');
        };

        // Event listeners
        document.getElementById('startButton').addEventListener('click', startGame);

        document.getElementById('failOverlay').addEventListener('click', () => {
            resetGame();
        });

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function startGame() {
            gameState = 'playing';
            document.getElementById('startOverlay').classList.remove('active');
            document.getElementById('startButton').style.display = 'none';
            gameLoop();
        }

        function resetGame() {
            gameState = 'start';
            player.x = 50;
            player.y = 50;
            flashlights = 3;
            flashlightActive = false;
            flashlightTimer = 0;
            darknessAlpha = 0.95;

            document.getElementById('failOverlay').classList.remove('active');
            document.getElementById('wrongwayOverlay').classList.remove('active');
            document.getElementById('rightwayOverlay').classList.remove('active');
            document.getElementById('startOverlay').classList.add('active');
            document.getElementById('startButton').style.display = 'block';
        }

        function activateFlashlight() {
            if (flashlights > 0 && !flashlightActive) {
                flashlights--;
                flashlightActive = true;
                flashlightTimer = FLASHLIGHT_DURATION;
                darknessAlpha = 0.3;

                // Check if player is on the right path
                checkPath();
            }
        }

        function checkPath() {
            // Simple path checking - if player is in certain areas
            // You can customize this based on the actual maze solution
            const isOnRightPath = player.x > 600 && player.y > 400;

            if (isOnRightPath) {
                showOverlay('rightwayOverlay', 2000);
            } else {
                showOverlay('wrongwayOverlay', 2000);
            }
        }

        function showOverlay(overlayId, duration) {
            const overlay = document.getElementById(overlayId);
            overlay.classList.add('active');

            setTimeout(() => {
                overlay.classList.remove('active');
            }, duration);
        }

        function updateFlashlight(deltaTime) {
            if (flashlightActive) {
                flashlightTimer -= deltaTime;

                if (flashlightTimer <= 0) {
                    flashlightActive = false;
                    darknessAlpha = 0.95;

                    // Check if out of flashlights
                    if (flashlights === 0) {
                        // Check if player reached the exit
                        if (!checkWinCondition()) {
                            gameOver();
                        }
                    }
                }
            }
        }

        function checkWinCondition() {
            // Check if player is near the exit (bottom right area with arrow)
            return player.x > 1100 && player.y > 700;
        }

        function gameOver() {
            gameState = 'failed';
            document.getElementById('failOverlay').classList.add('active');
        }

        function updatePlayer() {
            if (gameState !== 'playing') return;

            let newX = player.x;
            let newY = player.y;

            // Movement with WASD
            if (keys['w']) newY -= player.speed;
            if (keys['s']) newY += player.speed;
            if (keys['a']) newX -= player.speed;
            if (keys['d']) newX += player.speed;

            // Check collision with walls
            if (mazeLoaded && !checkCollision(newX, newY)) {
                player.x = newX;
                player.y = newY;
            }

            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

            // Check win condition
            if (checkWinCondition()) {
                winGame();
            }
        }

        function checkCollision(x, y) {
            if (!mazeLoaded) return false;

            // Create a temporary canvas to read pixel data from the maze
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mazeImg.width;
            tempCanvas.height = mazeImg.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(mazeImg, 0, 0);

            // Scale coordinates to maze image size
            const scaleX = mazeImg.width / canvas.width;
            const scaleY = mazeImg.height / canvas.height;
            const checkX = Math.floor(x * scaleX);
            const checkY = Math.floor(y * scaleY);

            try {
                const pixelData = tempCtx.getImageData(checkX, checkY, 1, 1).data;
                // If pixel is white (wall), collision detected
                // White pixels have high RGB values
                const isWall = pixelData[0] > 200 && pixelData[1] > 200 && pixelData[2] > 200;
                return isWall;
            } catch (e) {
                return false;
            }
        }

        function winGame() {
            gameState = 'won';
            alert('Congratulations! You escaped the Labyrinth of Shadows!');
            resetGame();
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
                // Draw player (red circle)
                ctx.fillStyle = '#ff3333';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();

                // Draw player glow when flashlight is on
                if (flashlightActive) {
                    const gradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.size + 10);
                    gradient.addColorStop(0, 'rgba(255, 51, 51, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 51, 51, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw darkness overlay with flashlight effect
                ctx.save();

                if (flashlightActive) {
                    // Create flashlight gradient
                    const gradient = ctx.createRadialGradient(
                        player.x, player.y, 30,
                        player.x, player.y, 200
                    );
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.3)');
                    gradient.addColorStop(1, `rgba(0, 0, 0, ${darknessAlpha})`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    // Just darkness
                    ctx.fillStyle = `rgba(0, 0, 0, ${darknessAlpha})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Small light around player
                    const smallGradient = ctx.createRadialGradient(
                        player.x, player.y, 0,
                        player.x, player.y, 40
                    );
                    smallGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    smallGradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');

                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillStyle = smallGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.globalCompositeOperation = 'source-over';
                }

                ctx.restore();
            }
        }

        function gameLoop() {
            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            updatePlayer();
            updateFlashlight(deltaTime);
            draw();

            if (gameState === 'playing') {
                requestAnimationFrame(gameLoop);
            }
        }
    </script>
</body>
</html>
